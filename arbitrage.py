"""
Math 260
Project
Spring 2022
Partner 1: William "Cason" Pierce
Partner 2: Graham Fay
Date: 4-15-22
"""

# Import math and p3tests.
import math
from arbitrageTests import *

################################################################################

"""
detectArbitrage: this function is used to detect the existence of a negative cost cycle in a graph

INPUTS
adjList: an adjacency list of Vertex objects
adjMat: a 2D list of currency exchange rates, as generated by the rates2mat function
tol: a tolerance value that is set to 1e-15 and should not be altered

OUTPUTS
cycleVertex: a list of the ranks of the vertices that are found in a negative cost cycle of the graph
(Note: if no negative cost cycle exists in the graph, an empty list will be returned)
"""
def detectArbitrage(adjList, adjMat, tol=1e-15):
    # Set V as the number of vertices in the adjacency list
    V = len(adjList)

    # Set the initial dist values to infinity and the prev values None for each vertex
    for curr in adjList:
        curr.dist = math.inf
        curr.prev = None

    # Set the distance of the first vertex as 0
    adjList[0].dist = 0

    # Perform the |V| - 1 iterations of the Bellman Ford algorithm
    for inter in range(V - 1):
        for current in adjList:
            for other in current.neigh:
                if other.dist > current.dist + adjMat[current.rank][other.rank] + tol:
                    other.dist = current.dist + adjMat[current.rank][other.rank]
                    other.prev = current

    # Set changedVertex as None and perform one final iteration to check for negative cost cycles which will
    changedVertex = None
    for current in adjList:
        for other in current.neigh:
            if other.dist > current.dist + adjMat[current.rank][other.rank] + tol:
                other.dist = current.dist + adjMat[current.rank][other.rank]
                other.prev = current
                changedVertex = other
                break


    # If we iterate through final and newFinal without finding any changes, there is no arbitrage
    if changedVertex is None:
        print("No arbitrage found")
        return []


    # Create a visited list that will keep track of the vertex ranks in the negative cost cycle
    visited = []
    visited.append(changedVertex.rank)

    # Iterate backwards through the graph using the .prev atribute of each vertex to find
    # the closed cycle and append the ranks of these vertices to the visited list
    while(changedVertex.prev.rank not in visited):
        changedVertex = changedVertex.prev
        visited.append(changedVertex.rank)

    # Set startCycle as the first element in the closed cycle and find its index in the visited list
    startCycle = changedVertex.prev
    startIndex = visited.index(startCycle.rank)

    # Set cycleVertex as the closed negative cost cycle
    cycleVertex = visited[startIndex:]
    cycleVertex.append(startCycle.rank)

    # Reverse the order of cycleVertex so that it is in the correct order
    cycleVertex.reverse()

    return cycleVertex

################################################################################

"""
rates2mat
This function takes the exchange rates of different currencies and computes the 
negative log of each rate. The edge weights of our graph in the Bellman Ford algorithm
will correspond to these newly calculated rates.

INPUTS
rates: a matrix of exchange rates

OUTPUTS
adjMat: the adjacency matrix with entries that are the negative log of the entries 
from our input matrix "rates".
"""
def rates2mat(rates):
    # Return an adjacency matrix using the negative log to calculate proper edge weights
    adjMat = [[-math.log(R) for R in row] for row in rates]
    return adjMat


"""
Main function.
"""
if __name__ == "__main__":
    testRates()